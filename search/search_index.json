{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"feature_engineering/","title":"Feature Engineering: Temporal Rainfall (Per\u2011Cell, No Aggregation)","text":"<p>This page documents <code>src/feature_engin.py</code>, which generates a starter set of temporal rainfall features per grid cell (no spatial aggregation). It operates on hourly rainfall (mm) where each data column is named like <code>LAT,LON</code> (e.g., <code>1.2200,103.6000</code>) and the index (or <code>timestamp</code> column) is hourly.</p>"},{"location":"feature_engineering/#at-a-glance","title":"At a glance","text":"<ul> <li>Per\u2011cell features only (you will get many columns: ~30\u201335 per cell \u00d7 80 cells \u2248 2.4\u20132.8k total).</li> <li>Past\u2011only features (no leakage): lags, rolling sums/max, APIs, dry\u2011spell, rainnow, delta.</li> <li>Forecast\u2011aware features (look\u2011ahead): next\u2011H sum/max, time\u2011to\u2011peak (TTP), frontshare.</li> <li>Column naming: <code>&lt;feature&gt;_&lt;LAT&gt;_&lt;LON&gt;</code> \u2192 e.g., <code>lag1h_1.2200_103.6000</code>.</li> </ul> <p>Leakage note Forecast features are computed by looking forward in the same historical series. In production, replace them with actual forecast inputs available at time t up to your prediction horizon.</p>"},{"location":"feature_engineering/#input-expectations","title":"Input expectations","text":"<ul> <li>Columns: <code>timestamp</code> (used as index) + many rainfall columns named <code>LAT,LON</code> (mm/h).  </li> <li>Frequency: hourly.  </li> <li>Timezone: Asia/Singapore (informational only; functions do not enforce tz).</li> </ul>"},{"location":"feature_engineering/#quick-start","title":"Quick start","text":"<pre><code>import pandas as pd\nfrom src.feature_engin import engineer_temporal_features_all_cells\n\ndf = pd.read_csv(\"../data/sg_rainfall_processed.csv\", parse_dates=[\"timestamp\"]).set_index(\"timestamp\")\nfeats = engineer_temporal_features_all_cells(df)   # uses sensible defaults\nfeats.to_csv(\"../data/rainfall_temporal_features.csv\")\n\nprint(feats.shape)  # (n_rows, n_features)\n</code></pre> <p>Typical size: ~30\u201335 features \u00d7 80 cells \u2248 2,400\u20132,800 columns.</p>"},{"location":"feature_engineering/#feature-families","title":"Feature families","text":""},{"location":"feature_engineering/#1-pastonly-no-leakage","title":"1) Past\u2011only (no leakage)","text":"<ul> <li>Lags: <code>lag{h}h</code> for <code>h \u2208 {1,2,3,4,5,6,12,24}</code> Rain at t\u2212h hours.</li> <li>Rolling sums: <code>sum{w}h</code> for <code>w \u2208 {3,6,12,24}</code> Total rain in the last w hours (including t). </li> <li>Rolling max: <code>max{w}h</code> for <code>w \u2208 {3,6}</code> Peak 1\u2011h intensity in the last w hours (including t). </li> <li>API (wetness memory): <code>api_hl{hl}h</code> for half\u2011lives <code>{6,24,168}</code> Exponential index with decay k = 0.5 ** (1/hl). </li> <li>Dry\u2011spell: <code>dryspell</code> Consecutive dry hours before t (does not count t). \u201cDry\u201d means \u2264 0.2 mm by default. </li> <li>Instantaneous: <code>rainnow</code>, <code>delta1h</code> Is raining now? (<code>&gt; 0.2 mm</code> \u2192 1.0) and 1\u2011hour change (<code>t \u2212 (t\u22121)</code>).</li> </ul>"},{"location":"feature_engineering/#2-forecastaware-lookahead","title":"2) Forecast\u2011aware (look\u2011ahead)","text":"<ul> <li>Next\u2011H sums: <code>next{H}h_sum</code> for <code>H \u2208 {1,3,6,12}</code> Forecasted total rain in t+1..t+H.</li> <li>Next\u2011H max: <code>next{H}h_max</code> for <code>H \u2208 {3,6,12}</code> Max forecast intensity in t+1..t+H.</li> <li>Time\u2011to\u2011peak: <code>ttp_next{H}h</code> for <code>H \u2208 {6,12}</code> How many hours until the peak occurs in t+1..t+H (1..H).</li> <li>Frontshare: <code>frontshare_next{H}h</code> (default <code>H=12</code>) Fraction of forecast rain that falls in the first half of the horizon.</li> </ul> <p>Use forecast features only up to your prediction horizon H to avoid leakage.</p>"},{"location":"feature_engineering/#naming-convention","title":"Naming convention","text":"<p>Every feature is named <code>&lt;feature&gt;_&lt;LAT&gt;_&lt;LON&gt;</code>, preserving 4 decimal places from the input headers. Example: <code>sum6h_1.2914_103.8500</code>.</p>"},{"location":"feature_engineering/#function-reference-summary","title":"Function reference (summary)","text":""},{"location":"feature_engineering/#parse_value_columnsdf-liststr","title":"<code>parse_value_columns(df) -&gt; list[str]</code>","text":"<p>Return rainfall value columns that look like <code>\"lat,lon\"</code>.</p>"},{"location":"feature_engineering/#latlon_from_colcol-str-str","title":"<code>latlon_from_col(col) -&gt; (str, str)</code>","text":"<p>Split <code>\"lat,lon\"</code> into <code>(lat, lon)</code> strings for naming.</p>"},{"location":"feature_engineering/#feature_nameprefix-col-str","title":"<code>feature_name(prefix, col) -&gt; str</code>","text":"<p>Compose <code>\"prefix_LAT_LON\"</code> (e.g., <code>lag1h_1.2200_103.6000</code>).</p>"},{"location":"feature_engineering/#compute_lagss-hours-dictstr-series","title":"<code>compute_lags(s, hours) -&gt; dict[str, Series]</code>","text":"<p>Lag features <code>s(t \u2212 h)</code> for each <code>h</code>.</p>"},{"location":"feature_engineering/#compute_rolling_sumss-windows-dictstr-series","title":"<code>compute_rolling_sums(s, windows) -&gt; dict[str, Series]</code>","text":"<p>Rolling sums over the past <code>w</code> hours (including t).</p>"},{"location":"feature_engineering/#compute_rolling_maxs-windows-dictstr-series","title":"<code>compute_rolling_max(s, windows) -&gt; dict[str, Series]</code>","text":"<p>Rolling max over the past <code>w</code> hours (including t).</p>"},{"location":"feature_engineering/#compute_apis-halflife_hours-series","title":"<code>compute_api(s, halflife_hours) -&gt; Series</code>","text":"<p>Exponential Antecedent Precipitation Index with half\u2011life <code>hl</code> hours. <code>API_t = k*API_{t-1} + R_t</code>, where <code>k = 0.5 ** (1/hl)</code>.</p>"},{"location":"feature_engineering/#compute_dryspell_hourss-threshold02-series","title":"<code>compute_dryspell_hours(s, threshold=0.2) -&gt; Series</code>","text":"<p>Consecutive dry hours before t (does not count t). Dry means <code>\u2264 threshold</code> mm.</p>"},{"location":"feature_engineering/#compute_now_and_deltas-wet_threshold02-dictstr-series","title":"<code>compute_now_and_delta(s, wet_threshold=0.2) -&gt; dict[str, Series]</code>","text":"<p><code>rainnow</code> (1.0 if <code>&gt; wet_threshold</code> else 0.0), and <code>delta1h</code> (<code>t \u2212 (t\u22121)</code>).</p>"},{"location":"feature_engineering/#compute_future_sumss-horizons-dictstr-series","title":"<code>compute_future_sums(s, horizons) -&gt; dict[str, Series]</code>","text":"<p>Sum of future rain over <code>t+1..t+H</code> for each H.</p>"},{"location":"feature_engineering/#compute_future_maxs-horizons-dictstr-series","title":"<code>compute_future_max(s, horizons) -&gt; dict[str, Series]</code>","text":"<p>Max future intensity over <code>t+1..t+H</code> for each H.</p>"},{"location":"feature_engineering/#compute_time_to_peaks-horizon-series","title":"<code>compute_time_to_peak(s, horizon) -&gt; Series</code>","text":"<p>Time (hours) until the peak occurs within <code>t+1..t+H</code> (1..H).</p>"},{"location":"feature_engineering/#compute_frontshares-horizon12-series","title":"<code>compute_frontshare(s, horizon=12) -&gt; Series</code>","text":"<p>Share of total future rain that falls in the first half of the horizon.</p>"},{"location":"feature_engineering/#engineer_temporal_features_per_celldf-col-kwargs-dictstr-series","title":"<code>engineer_temporal_features_per_cell(df, col, **kwargs) -&gt; dict[str, Series]</code>","text":"<p>Build the starter set for one coordinate column (no aggregation). Key knobs: <code>lag_hours</code>, <code>sum_windows</code>, <code>max_windows</code>, <code>api_halflives</code>, thresholds, horizons.</p>"},{"location":"feature_engineering/#engineer_temporal_features_all_cellsdf-kwargs-dataframe","title":"<code>engineer_temporal_features_all_cells(df, **kwargs) -&gt; DataFrame</code>","text":"<p>Build the starter set for all <code>LAT,LON</code> columns and return a feature table.</p>"},{"location":"feature_engineering/#edge-cases-nans","title":"Edge cases &amp; NaNs","text":"<ul> <li>Start/end of series create <code>NaN</code>s (lags/rollings at the start; look\u2011ahead at the end).  </li> <li><code>dryspell</code> counts before t; <code>frontshare</code> is <code>NaN</code> if total future rain is zero.  </li> <li>Handle missing values via model tolerance or imputation downstream.</li> </ul>"},{"location":"feature_engineering/#tips","title":"Tips","text":"<ul> <li>Consider <code>float32</code> downstream if memory is tight.  </li> <li>Save to Parquet for faster I/O when iterating.  </li> <li>Use blocked / rolling\u2011origin CV (no shuffling) for time\u2011series.</li> </ul>"},{"location":"feature_engineering/#example-tweak-windows-horizons","title":"Example: tweak windows &amp; horizons","text":"<pre><code>from src.feature_engin import engineer_temporal_features_all_cells\n\nfeats = engineer_temporal_features_all_cells(\n    df,\n    lag_hours=(1,2,3,6,12,24),\n    sum_windows=(3,6,12,24),\n    max_windows=(3,6),\n    api_halflives=(6,24,168),\n    dry_threshold=0.2,\n    wet_threshold=0.2,\n    future_sum_horizons=(1,3,6,12),\n    future_max_horizons=(3,6,12),\n    ttp_horizons=(6,12),\n    frontshare_h=12,\n)\n</code></pre>"},{"location":"feature_engineering/#optional-polish-mkdocs","title":"Optional polish (MkDocs)","text":"<p>If you use MkDocs Material, enable these to improve styling:</p> <pre><code>theme:\n  name: material\nmarkdown_extensions:\n  - admonition\n  - pymdownx.details\n  - pymdownx.superfences\n  - tables\n</code></pre> <p>This enables callouts, collapsible sections, and better fenced code blocks.</p>"},{"location":"api/feature_engin/","title":"API: feature_engin","text":""},{"location":"api/feature_engin/#src.feature_engin.compute_api","title":"<code>compute_api(s, halflife_hours)</code>","text":"<p>Compute an Antecedent Precipitation Index (API) with exponential decay.</p> <p>API_t = k * API_{t-1} + R_t,  where  k = 0.5 ** (1 / halflife_hours)</p> <p>Parameters:</p> <ul> <li> <code>s</code>               (<code>Series</code>)           \u2013            <p>Rainfall series (mm/h).</p> </li> <li> <code>halflife_hours</code>               (<code>int</code>)           \u2013            <p>Exponential half-life in hours (e.g., 6, 24, 168).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>A Series of API values (same index as s).</p> </li> </ul> Notes <ul> <li>API is a simple wetness memory; larger halflife =&gt; slower decay.</li> <li>Implemented via lightweight recursion; fast for hourly series.</li> </ul>"},{"location":"api/feature_engin/#src.feature_engin.compute_dryspell_hours","title":"<code>compute_dryspell_hours(s, threshold=0.2)</code>","text":"<p>Count consecutive dry hours BEFORE t (excludes current hour).</p> <p>Parameters:</p> <ul> <li> <code>s</code>               (<code>Series</code>)           \u2013            <p>Rainfall series (mm/h).</p> </li> <li> <code>threshold</code>               (<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>Rainfall &lt;= threshold is considered \"dry\" (default 0.2 mm).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>Series with the length (in hours) of the current dry spell before t.</p> </li> </ul> Example <p>If t-1..t-3 were dry and t is wet, value at t is 3. If t-1 is wet, value is 0.</p>"},{"location":"api/feature_engin/#src.feature_engin.compute_frontshare","title":"<code>compute_frontshare(s, horizon=12)</code>","text":"<p>Fraction of future rain in the FIRST half of the next <code>horizon</code> hours.</p> <p>Parameters:</p> <ul> <li> <code>s</code>               (<code>Series</code>)           \u2013            <p>Rainfall series (mm/h).</p> </li> <li> <code>horizon</code>               (<code>int</code>, default:                   <code>12</code> )           \u2013            <p>Lookahead horizon in hours (default 12). Uses t+1..t+horizon.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>Series of shares in [0,1] when total future rain &gt; 0; NaN when total == 0.</p> </li> </ul> Notes <ul> <li>Computed as rolling sums on s.shift(-1); both first-half and total are aligned.</li> <li>Choose horizon to match your prediction horizon H to avoid leakage.</li> </ul>"},{"location":"api/feature_engin/#src.feature_engin.compute_future_max","title":"<code>compute_future_max(s, horizons)</code>","text":"<p>Max of NEXT H hours (t+1..t+H) for each horizon H.</p> <p>Parameters:</p> <ul> <li> <code>s</code>               (<code>Series</code>)           \u2013            <p>Rainfall series (mm/h).</p> </li> <li> <code>horizons</code>               (<code>Iterable[int]</code>)           \u2013            <p>Iterable of horizons in hours (e.g., (3,6,12)).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Series]</code>           \u2013            <p>Dict mapping \"next{H}h_max\" -&gt; Series of forward max values.</p> </li> </ul> Notes <p>See leakage note in compute_future_sums().</p>"},{"location":"api/feature_engin/#src.feature_engin.compute_future_sums","title":"<code>compute_future_sums(s, horizons)</code>","text":"<p>Sum of NEXT H hours (t+1..t+H) for each horizon H.</p> <p>Parameters:</p> <ul> <li> <code>s</code>               (<code>Series</code>)           \u2013            <p>Rainfall series (mm/h).</p> </li> <li> <code>horizons</code>               (<code>Iterable[int]</code>)           \u2013            <p>Iterable of horizons in hours (e.g., (1,3,6,12)).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Series]</code>           \u2013            <p>Dict mapping \"next{H}h_sum\" -&gt; Series of forward sums.</p> </li> </ul> Notes <ul> <li>Implemented as rolling on s.shift(-1), right-aligned.</li> <li>In production, replace with actual forecast inputs available at time t.</li> </ul>"},{"location":"api/feature_engin/#src.feature_engin.compute_lags","title":"<code>compute_lags(s, hours)</code>","text":"<p>Compute lag features s(t - h) for each hour h.</p> <p>Parameters:</p> <ul> <li> <code>s</code>               (<code>Series</code>)           \u2013            <p>Rainfall series (mm/h), indexed by timestamp.</p> </li> <li> <code>hours</code>               (<code>Iterable[int]</code>)           \u2013            <p>Iterable of integer lags in hours (e.g., (1,2,3,6,12,24)).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Series]</code>           \u2013            <p>Dict mapping \"lag{h}h\" -&gt; Series lagged by h hours.</p> </li> </ul>"},{"location":"api/feature_engin/#src.feature_engin.compute_now_and_delta","title":"<code>compute_now_and_delta(s, wet_threshold=0.2)</code>","text":"<p>Compute 'is raining now' and 1-hour delta.</p> <p>Parameters:</p> <ul> <li> <code>s</code>               (<code>Series</code>)           \u2013            <p>Rainfall series (mm/h).</p> </li> <li> <code>wet_threshold</code>               (<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>Threshold above which the hour is considered \"wet\" (default 0.2 mm).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Series]</code>           \u2013            <p>Dict with: - \"rainnow\": 1.0 if s(t) &gt; wet_threshold else 0.0 - \"delta1h\": s(t) - s(t-1)</p> </li> </ul>"},{"location":"api/feature_engin/#src.feature_engin.compute_rolling_max","title":"<code>compute_rolling_max(s, windows)</code>","text":"<p>Compute rolling max intensities over past windows (including current t).</p> <p>Parameters:</p> <ul> <li> <code>s</code>               (<code>Series</code>)           \u2013            <p>Rainfall series (mm/h).</p> </li> <li> <code>windows</code>               (<code>Iterable[int]</code>)           \u2013            <p>Iterable of window sizes in hours (e.g., (3,6)).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Series]</code>           \u2013            <p>Dict mapping \"max{w}h\" -&gt; rolling max Series with window w.</p> </li> </ul>"},{"location":"api/feature_engin/#src.feature_engin.compute_rolling_sums","title":"<code>compute_rolling_sums(s, windows)</code>","text":"<p>Compute rolling sums over past windows (including current t).</p> <p>Parameters:</p> <ul> <li> <code>s</code>               (<code>Series</code>)           \u2013            <p>Rainfall series (mm/h).</p> </li> <li> <code>windows</code>               (<code>Iterable[int]</code>)           \u2013            <p>Iterable of window sizes in hours (e.g., (3,6,12,24)).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Series]</code>           \u2013            <p>Dict mapping \"sum{w}h\" -&gt; rolling sum Series with window w.</p> </li> <li> <code>Dict[str, Series]</code>           \u2013            <p>Uses min_periods=1 so early rows are populated (may be partial windows).</p> </li> </ul>"},{"location":"api/feature_engin/#src.feature_engin.compute_time_to_peak","title":"<code>compute_time_to_peak(s, horizon)</code>","text":"<p>Time-to-peak (in hours) within NEXT <code>horizon</code> hours (exclude current t).</p> <p>Parameters:</p> <ul> <li> <code>s</code>               (<code>Series</code>)           \u2013            <p>Rainfall series (mm/h).</p> </li> <li> <code>horizon</code>               (<code>int</code>)           \u2013            <p>Lookahead window size in hours (e.g., 6 or 12).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>Series where each value is the number of hours until the peak</p> </li> <li> <code>Series</code>           \u2013            <p>intensity occurs within (t+1 .. t+horizon).</p> </li> <li> <code>Series</code>           \u2013            <p>NaN if no future window or all-NaN window.</p> </li> </ul> Notes <ul> <li>If the first future hour is the max, value is 1. If the max is at t+H, value is H.</li> <li>For model safety, treat NaNs as missing rather than 0.</li> </ul>"},{"location":"api/feature_engin/#src.feature_engin.engineer_temporal_features_all_cells","title":"<code>engineer_temporal_features_all_cells(df, **kwargs)</code>","text":"<p>Build the starter temporal features for all coordinate columns in <code>df</code>.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame indexed by timestamp; columns: \"lat,lon\" rainfall series.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Keyword arguments passed through to <code>engineer_temporal_features_per_cell</code>,      e.g., lag_hours, sum_windows, api_halflives, thresholds, horizons.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame indexed by timestamp with only engineered feature columns,</p> </li> <li> <code>DataFrame</code>           \u2013            <p>concatenating all per-cell outputs. Columns are sorted alphabetically.</p> </li> </ul> Example <p>feats = engineer_temporal_features_all_cells(df, ...     lag_hours=(1,2,3,6,12,24), ...     future_sum_horizons=(1,3,6,12)) feats.shape (n_rows, n_features)</p>"},{"location":"api/feature_engin/#src.feature_engin.engineer_temporal_features_per_cell","title":"<code>engineer_temporal_features_per_cell(df, col, *, lag_hours=(1, 2, 3, 4, 5, 6, 12, 24), sum_windows=(3, 6, 12, 24), max_windows=(3, 6), api_halflives=(6, 24, 168), dry_threshold=0.2, wet_threshold=0.2, future_sum_horizons=(1, 3, 6, 12), future_max_horizons=(3, 6, 12), ttp_horizons=(6, 12), frontshare_h=12)</code>","text":"<p>Build the starter per-cell temporal features for one coordinate column.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame indexed by timestamp; must contain the column <code>col</code>.</p> </li> <li> <code>col</code>               (<code>str</code>)           \u2013            <p>Column name in \"lat,lon\" format (e.g., \"1.2200,103.6000\").</p> </li> <li> <code>lag_hours</code>               (<code>Iterable[int]</code>, default:                   <code>(1, 2, 3, 4, 5, 6, 12, 24)</code> )           \u2013            <p>Hours for lag features s(t - h).</p> </li> <li> <code>sum_windows</code>               (<code>Iterable[int]</code>, default:                   <code>(3, 6, 12, 24)</code> )           \u2013            <p>Past rolling sum windows (hours).</p> </li> <li> <code>max_windows</code>               (<code>Iterable[int]</code>, default:                   <code>(3, 6)</code> )           \u2013            <p>Past rolling max windows (hours).</p> </li> <li> <code>api_halflives</code>               (<code>Iterable[int]</code>, default:                   <code>(6, 24, 168)</code> )           \u2013            <p>Half-lives (hours) for exponential API (e.g., 6, 24, 168).</p> </li> <li> <code>dry_threshold</code>               (<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>Threshold (mm) for \"dry\" in dryspell computation.</p> </li> <li> <code>wet_threshold</code>               (<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>Threshold (mm) for \"rainnow\" indicator.</p> </li> <li> <code>future_sum_horizons</code>               (<code>Iterable[int]</code>, default:                   <code>(1, 3, 6, 12)</code> )           \u2013            <p>Horizons (hours) for forward sum features (t+1..t+H).</p> </li> <li> <code>future_max_horizons</code>               (<code>Iterable[int]</code>, default:                   <code>(3, 6, 12)</code> )           \u2013            <p>Horizons (hours) for forward max features (t+1..t+H).</p> </li> <li> <code>ttp_horizons</code>               (<code>Iterable[int]</code>, default:                   <code>(6, 12)</code> )           \u2013            <p>Horizons (hours) for time-to-peak features.</p> </li> <li> <code>frontshare_h</code>               (<code>int</code>, default:                   <code>12</code> )           \u2013            <p>Horizon (hours) for \"frontshare\" feature (default 12).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Series]</code>           \u2013            <p>Dict mapping feature_name -&gt; Series, with names like:</p> </li> <li> <code>Dict[str, Series]</code>           \u2013            <ul> <li>lag1h_1.2200_103.6000</li> </ul> </li> <li> <code>Dict[str, Series]</code>           \u2013            <ul> <li>sum6h_1.2200_103.6000</li> </ul> </li> <li> <code>Dict[str, Series]</code>           \u2013            <ul> <li>api_hl24h_1.2200_103.6000</li> </ul> </li> <li> <code>Dict[str, Series]</code>           \u2013            <ul> <li>dryspell_1.2200_103.6000</li> </ul> </li> <li> <code>Dict[str, Series]</code>           \u2013            <ul> <li>rainnow_1.2200_103.6000</li> </ul> </li> <li> <code>Dict[str, Series]</code>           \u2013            <ul> <li>next12h_sum_1.2200_103.6000</li> </ul> </li> <li> <code>Dict[str, Series]</code>           \u2013            <ul> <li>ttp_next6h_1.2200_103.6000</li> </ul> </li> <li> <code>Dict[str, Series]</code>           \u2013            <ul> <li>frontshare_next12h_1.2200_103.6000</li> </ul> </li> </ul> Notes <ul> <li>All features are computed per cell; no spatial aggregation is performed.</li> <li>Forward-looking features use future values in the same series and must be   replaced by true forecasts at runtime to avoid information leakage.</li> </ul>"},{"location":"api/feature_engin/#src.feature_engin.feature_name","title":"<code>feature_name(prefix, col)</code>","text":"<p>Compose a per-cell feature name using 'prefix_LAT_LON'.</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str</code>)           \u2013            <p>Feature prefix (e.g., \"lag1h\", \"sum6h\").</p> </li> <li> <code>col</code>               (<code>str</code>)           \u2013            <p>Original column name in \"lat,lon\" format.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The feature name \"prefix_LAT_LON\", e.g. \"lag1h_1.2200_103.6000\".</p> </li> </ul>"},{"location":"api/feature_engin/#src.feature_engin.latlon_from_col","title":"<code>latlon_from_col(col)</code>","text":"<p>Split a 'lat,lon' header into ('LAT', 'LON') strings.</p> <p>Parameters:</p> <ul> <li> <code>col</code>               (<code>str</code>)           \u2013            <p>Column name formatted as \"lat,lon\" (e.g., \"1.2200,103.6000\").</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[str, str]</code>           \u2013            <p>Tuple of (lat_str, lon_str) with any whitespace trimmed.</p> </li> </ul>"},{"location":"api/feature_engin/#src.feature_engin.parse_value_columns","title":"<code>parse_value_columns(df)</code>","text":"<p>Return the rainfall value columns that look like 'lat,lon'.</p> <p>Parameters:</p> <ul> <li> <code>df</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame with a 'timestamp' column (or index) plus many 'lat,lon' columns.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>A list of column names whose header contains a comma (assumed to be 'lat,lon').</p> </li> </ul>"}]}